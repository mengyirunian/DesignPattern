package com.blackfish.creator.builderPattern;

/**
 * 这一处是写建造者模式
 * 建造者模式，我个人理解，重点在于建造对象。
 * 而这个模式的意义在于如何简洁、灵活地构建对象。（当然，听起来就像是废话）
 */
public class Start {

    public static void main(String[] args) {

        /**
         * 好吧，现在我们来举个例子
         * 比如我们就来建造一个学生对象。
         * 那么以往我们是怎么做的呢
         */

        StudentOrigin studentOrigin1 = new StudentOrigin();

        /**
         * 没错，就是这么简单粗暴无脑
         * 那如果我想赋值呢
         */

        studentOrigin1.setStuNo("001");
        studentOrigin1.setName("zhangsan");
        studentOrigin1.setAddress("Beijing");

        /**
         * 这种最基本的POJO的操作，肯定难不倒
         * 另外还可以用更加简洁的方式
         */

        StudentOrigin studentOrigin2 = new StudentOrigin("001", "zhangsan", "Beijing");

        /**
         * 额，这样子不是很完美嘛
         * 而且构造对象起来也没啥问题
         * 那么这个建造者模式还有啥卵用
         *
         * 不知道是否注意到，此时此刻，我们是作为外部调用者
         * 但是却能够干预到对象的创建以及对象创建时候内部属性的赋值。
         *
         * 那么这个设计模式的意义就能明白了
         * 我们作为外部调用者，则应该很简单地只是使用这个对象
         * 而如果对象不存在，则应该有一些具有安全机制的角色对象
         * 来提供所需要的对象
         *
         * 鉴于这种情况，我们再来看看建造者设计模式的定义：
         * -->将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示
         */

        /**
         * 参考了不少资料，我发现有一个例子觉得比较切合
         * 而且在我们日常开发当中也频繁存在
         * 业务背景大概是这样的：
         * 在目前多个系统开发的环境中，系统之间会进行频繁的数据交互
         * 而每个系统所需要的数据形式可能不太一样
         * 例如，A系统会对外提供一些基础数据的模型
         * 但是B系统或者C系统需要从A提供的数据进行修改、转换、忽略等操作，即对原始数据的二次改造
         * 那么如将建造者模式运用其中，会怎么样呢？
         */

        /**
         * 比如我们从A系统的数据库中获取了一个原始数据Amsg
         * 然后mock信息如下
         */

        Amsg amsg = new Amsg();
        amsg.setId(1L);
        amsg.setMsg("hello, world");

        /**
         * 接着B系统收到这个数据
         * 然后按照以前的做法，就会自己构造一个Bmsg对象
         * 那如果按照建造者模式，则如下：
         *
         */

        Bmsg bmsg = new Director().getBmsg(amsg);
        System.out.println(bmsg);

        /**
         * 因为我们知道Bmsg是按照对Amsg对象改造后得到的
         * 而对于B系统其实只需要使用对象而已
         * 那么是否可以收回B系统对Bmsg构造的权限
         * 而只是单纯地让其只使用调用权限
         *
         * 一来，在权限上可以厘清，二来，对于B系统而言不需要关心怎么去构造这个Bmsg
         */

        /**
         * 对于Cmsg也是同样的道理
         */
        Cmsg cmsg = new Director().getCmsg(amsg);
        System.out.println(cmsg);

        /**
         * 那么，这里可能会有疑问，这样一来，这个建造者模式和工厂模式有什么不一样
         *
         * 工厂模式的关注点在于怎么获取对象，而建造者模式的关注点在于怎么构建对象。
         * 在我们的学习中，可以体会到
         * 工厂模式的运用，在于怎么获取一个对象，而对对象的改造的权限没有那么严格
         * 而建造者模式的运用，本身就保证了对象的构造过程，即更关心对象构造过程当中的内容
         * 有些资料说，建造者模式需要保证对象构造的顺序问题
         * 在我看来其实是一个道理，即构造过程中内容保证
         * 或者说，工厂模式的行为其实是一个create，而建造者模式的行为其实是一个builder
         *
         */

    }

}
